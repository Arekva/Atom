using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using Silk.NET.Vulkan;

namespace Atom.Engine.DDS;

using dxf = DirectX.Format;
using vkf = ImageFormat;

public static class DDSLoader
{
    // ReSharper disable once SwitchExpressionHandlesSomeKnownEnumValuesWithExceptionInDefault
    private static ImageFormat GetVkBCFormat(DirectX.Format dxformat, AlphaModes alphaMode)
    {
        return dxformat switch
        {
            // BC1
            dxf.BC1_UNorm when alphaMode is AlphaModes.Straight => vkf.BC1_RGBA_UNorm_Block,
            dxf.BC1_UNorm when alphaMode is AlphaModes.Opaque => vkf.BC1_RGB_UNorm_Block,
            dxf.BC1_UNorm_SRGB when alphaMode is AlphaModes.Straight => vkf.BC1_RGBA_sRGB_Block,
            dxf.BC1_UNorm_SRGB when alphaMode is AlphaModes.Opaque => vkf.BC1_RGB_sRGB_Block,
            dxf.BC1_Typeless => throw new NotImplementedException("Typeless BC1 is not available on Vulkan."),

            // BC2
            dxf.BC2_UNorm => vkf.BC2_UNorm_Block,
            dxf.BC2_UNorm_SRGB => vkf.BC2_sRGB_Block,

            // BC3
            dxf.BC3_UNorm => vkf.BC3_UNorm_Block,
            dxf.BC3_UNorm_SRGB => vkf.BC3_sRGB_Block,

            // BC4
            dxf.BC4_UNorm => vkf.BC4_UNorm_Block,
            dxf.BC4_SNorm => vkf.BC4_SNorm_Block,

            // BC5
            dxf.BC5_UNorm => vkf.BC5_UNorm_Block,
            dxf.BC5_SNorm => vkf.BC5_SNorm_Block,
            dxf.BC5_Typeless => throw new NotImplementedException("Typeless BC5 is not available on Vulkan."),

            // BC6
            dxf.BC6H_UFloat16 => vkf.BC6H_UFloat_Block,
            dxf.BC6H_SFloat16 => vkf.BC6H_SFloat_Block,
            dxf.BC6H_Typeless => throw new NotImplementedException("Typeless BC6H is not available on Vulkan."),

            // BC7
            dxf.BC7_UNorm => vkf.BC7_UNorm_Block,
            dxf.BC7_UNorm_SRGB => vkf.BC7_sRGB_Block,
            dxf.BC7_Typeless => throw new NotImplementedException("Typeless BC7 is not available on Vulkan."),


            _ => throw new InvalidDDSFile($"DirectX format {dxformat} (Alpha: {alphaMode}) is not a valid " +
                                          $"DirectDraw format.")
        };
    }

    public static unsafe IImage Load(Device device, uint transferQueue, Stream stream)
    {
        const uint DDS_MAGIC = (uint)FourCharCodes.DDS;

        ulong index = 0UL;


        // First verify if this is a DDS texture

        uint magic = 0U;
        stream.Read(new(&magic, 4));

        if (DDS_MAGIC != magic)
        {
            throw new InvalidDDSFile($"The magic of the file ({magic}) is not the DDS magic " +
                                     $"(DDS as fourCC: {DDS_MAGIC})."
            );
        }



        // Get information from the base DDS Header 

        Header header;
        stream.Read(new(&header, (int)Header.STRUCTURE_SIZE));
        header.ThrowIfWrongSize();
        header.PixelFormat.ThrowIfWrongSize();

        DXT10Header dxt10Header;
        stream.Read(new(&dxt10Header, Unsafe.SizeOf<DXT10Header>()));


        // Some sanitary header checking

        if (header.PixelFormat.FourCharCode != FourCharCodes.DX10)
        {
            throw new NotImplementedException("Only DX10 DDS files are implemented.");
        }

        uint vkWidth = header.Width == 0
            ? throw new InvalidDDSFile("No width is specified in DDS file's header.")
            : header.Width;
        uint vkHeight = Math.Max(1, header.Height); // 1D textures might not have a height set.
        uint vkDepth = Math.Max(1, header.Depth); // 1D & 2D textures might not have a depth set.

        uint vkMipLevels = header.MipMapCount;

        uint vkArrayLayers = Math.Max(1, dxt10Header.ArraySize);

        ImageType vkImageType = (ImageType)((uint)dxt10Header.ResourceDimension - 2);

        ImageFormat vkFormat = GetVkBCFormat(dxt10Header.Format, dxt10Header.MiscFlags2);

        // No other information is required for Vulkan, let's create that image !
        ulong linearSize = header.PitchOrLinearSize;
        ulong minLinearSize = vkFormat is
            ImageFormat.BC1_RGB_UNorm_Block or
            ImageFormat.BC1_RGBA_UNorm_Block or
            ImageFormat.BC1_RGB_sRGB_Block or
            ImageFormat.BC1_RGBA_sRGB_Block
            ? 8UL // dxt1 is 8bit while dxt2-5 are 16bit (for square texture)
            : 16UL;

        Span<ulong> mipLengths = stackalloc ulong[(int)vkMipLevels];
        for (int mip = 0; mip < vkMipLevels; mip++)
        {
            mipLengths[mip] = linearSize;
            linearSize = Math.Max(minLinearSize, linearSize / 4);
        }

        uint transferQueueIndex = transferQueue;


        // Create the final image
        SlimImage image = new (
            device,
            type: vkImageType,
            format: (Format)vkFormat,
            extent: new Extent3D(vkWidth, vkHeight, vkDepth),
            mipLevels: vkMipLevels,
            arrayLayers: vkArrayLayers,
            samples: SampleCountFlags.SampleCount1Bit, // unrelated to dds
            tiling: ImageTiling.Optimal, // unrelated to dds
            usage: ImageUsageFlags.ImageUsageTransferDstBit | ImageUsageFlags.ImageUsageTransferSrcBit, // unrelated to dds
            sharingMode: SharingMode.Exclusive,
            queueFamilyIndices: ReadOnlySpan<uint>.Empty,
            ImageLayout.Undefined // unrelated to dds
        );
        image.CreateDedicatedMemory(device, MemoryPropertyFlags.DeviceLocal);

        // create image with max caps for one final resource.
        // so it is used as a buffer for all the other transfers.

        MemoryRequirements stagingReqs;
        using (ImageCore stagingImage = new (
            device,
            vkImageType,
            vkFormat,
            extent: new Extent3D<uint>(vkWidth, vkHeight, vkDepth),
            mipLevels: 1,
            arrayLayers: 1,
            multisampling: SampleCountFlags.SampleCount1Bit,
            ImageTiling.Linear,
            usages: ImageUsageFlags.ImageUsageTransferSrcBit,
            ImageLayout.Undefined,
            SharingMode.Exclusive,
            uniqueQueueFamilies: transferFamily.AsSpan()
        ))
        {
            stagingReqs = stagingImage.MemoryRequirements;
        } // yes it's stupid, but VK_KHR_Maintenance4 isn't available :(

        uint totalStagingImages = vkArrayLayers * vkMipLevels;

        Span<ImageMemoryBarrier> makeTransferReadyBarriers = stackalloc ImageMemoryBarrier[(int)totalStagingImages + 1];

        ref ImageMemoryBarrier imageReadyBarrier = ref makeTransferReadyBarriers[^1];

        imageReadyBarrier = new ImageMemoryBarrier(
            image,

            sourceAccessMask: AccessFlags.None_KHR,
            destinationAccessMask: AccessFlags.TransferWrite,

            oldLayout: ImageLayout.Undefined,
            newLayout: ImageLayout.TransferDestinationOptimal,

            sourceQueueFamily: transferQueue.Family,
            destinationQueueFamily: transferQueue.Family,
            
            image.SelectSubresourceRange(Carbon.Core.ImageAspectFlags.Color)
        );


        ImageMemoryBarrier imageEndBarrier = imageReadyBarrier;
        {
            imageEndBarrier.OldLayout = ImageLayout.TransferDestinationOptimal;
            imageEndBarrier.SourceAccessMask = AccessFlags.TransferWrite;
            imageEndBarrier.SourceQueueFamilyIndex = transferQueueIndex;

            imageEndBarrier.NewLayout = ImageLayout.ShaderReadOnlyOptimal;
            imageEndBarrier.DestinationAccessMask = AccessFlags.ShaderRead;
            imageEndBarrier.DestinationQueueFamilyIndex = transferQueueIndex;
        };

        ImageCore[] stagingImages = new ImageCore[totalStagingImages];

        ulong totalDataRequired = 0UL;
        Carbon.Core.MemoryRequirements[] stagingMemoryRequirements = new Carbon.Core.MemoryRequirements[totalStagingImages];

        Carbon.Core.ImageSubresourceRange mipImageSubresource = new()
        {
            AspectMask = Carbon.Core.ImageAspectFlags.Color,
            BaseArrayLayer = 0, LayerCount = 1,
            BaseMipLevel = 0, LevelCount = 1
        };

        for (uint array = 0U; array < vkArrayLayers; array++)
        {
            uint mipWidth = vkWidth, mipHeight = vkHeight, mipDepth = vkDepth;
            for (uint mip = 0U; mip < vkMipLevels; mip++)
            {
                uint i = array * vkArrayLayers + mip;

                ImageCore mipImage = stagingImages[i] = new ImageCore(
                    device,
                    vkImageType,
                    vkFormat,
                    extent: new Extent3D<uint>(mipWidth, mipHeight, mipDepth),
                    mipLevels: 1,
                    arrayLayers: 1,
                    multisampling: Multisampling.x1,
                    ImageTiling.Linear,
                    usages: ImageUsageFlags.TransferSource,
                    ImageLayout.Undefined,
                    SharingMode.Exclusive,
                    uniqueQueueFamilies: transferFamily.AsSpan()
                );

                Carbon.Core.MemoryRequirements mipReqs = stagingMemoryRequirements[i] = mipImage.MemoryRequirements;
                totalDataRequired += mipReqs.Size;

                ImageMemoryBarrier mipReadyBarrier = imageReadyBarrier;
                {
                    mipReadyBarrier.Image = mipImage.VK;
                    mipReadyBarrier.NewLayout = ImageLayout.TransferSourceOptimal;
                    mipReadyBarrier.DestinationAccessMask = AccessFlags.TransferRead;
                    mipReadyBarrier.SubresourceRange = mipImageSubresource;
                }

                makeTransferReadyBarriers[(int)i] = mipReadyBarrier;

                mipWidth  = Math.Max(1, mipWidth / 2);
                mipHeight = Math.Max(1, mipHeight / 2);
                mipDepth  = Math.Max(1, mipDepth / 2);
            }
        }

        using Memory.Memory stagingMemory = new (
            device,
            Math.Max(stagingReqs.Size, totalDataRequired),
            device.PhysicalDevice.FindMemoryType(
                stagingReqs.MemoryTypeBits,
                properties: Carbon.Core.MemoryPropertyFlags.HostCoherent | Carbon.Core.MemoryPropertyFlags.HostVisible
            )
        );

        using MemoryMap<byte> map = stagingMemory.Map();


        Carbon.Core.ImageSubresourceLayers mipSubResource = new()
        {
            AspectMask = Carbon.Core.ImageAspectFlags.Color,
            BaseArrayLayer = 0U, LayerCount = 1U, MipLevel = 0U
        };

        ulong dataIndex = 0UL;

        for (int i = 0; i < totalStagingImages; i++)
        {
            ulong size = stagingMemoryRequirements[i].Size;
            
            stagingImages[i].BindMemory(stagingMemory.Segment(dataIndex, size));
            dataIndex += size;
        }


        using CommandPool transferPool = new (device, transferQueue.Family);

        CommandBuffer cmd = transferPool.Allocate();

        dataIndex = 0UL;
        using (CommandRecorder recorder = cmd.Record()!)
        {
            // make all the image ready to send or receive cpu data
            recorder.PipelineBarrier(
                sourceStageMask: Carbon.Core.PipelineStageFlags.TopOfPipe,
                destinationStageMask: Carbon.Core.PipelineStageFlags.Transfer,
                makeTransferReadyBarriers
            );

            for (uint array = 0U; array < vkArrayLayers; array++)
            {
                uint mipWidth = vkWidth, mipHeight = vkHeight, mipDepth = vkDepth;
                for (uint mip = 0U; mip < vkMipLevels; mip++)
                {
                    uint i = array * vkArrayLayers + mip;

                    ulong mipSize = mipLengths[(int)mip];

                    stream.Read(map.AsSpan(dataIndex, mipSize));

                    dataIndex += stagingMemoryRequirements[i].Size;

                    recorder.CopyImage(
                        sourceImage: stagingImages[i].VK,
                        sourceImageLayout: ImageLayout.TransferSourceOptimal,
                        destinationImage: image.VK,
                        destinationImageLayout: ImageLayout.TransferDestinationOptimal,
                        new Carbon.Core.ImageCopy()
                        {
                            SourceOffset = default,
                            SourceSubresource = mipSubResource,

                            DestinationOffset = default,
                            DestinationSubresource = new()
                            {
                                AspectMask = Carbon.Core.ImageAspectFlags.Color,
                                BaseArrayLayer = array, LayerCount = 1, MipLevel = mip
                            },

                            Extent = new Carbon.Extent3D<uint>(mipWidth, mipHeight, mipDepth)
                        }
                    );

                    mipWidth = Math.Max(1, mipWidth / 2);
                    mipHeight = Math.Max(1, mipHeight / 2);
                    mipDepth = Math.Max(1, mipDepth / 2);
                }
            }

            // make the final image ready to be used from shaders
            // when I'll have a render queue lol
            /*recorder.PipelineBarrier(
                sourceStageMask: PipelineStageFlags.Transfer,
                destinationStageMask: PipelineStageFlags.FragmentShader,
                finalReadyBarrier.AsSpan()
            );*/
        }

        transferQueue.Submit(cmd);

        for (int i = 0; i < totalStagingImages; i++)
        {
            stagingImages[i].Dispose();
        }
        
        // oh yes, good ol' thicc reflective instantiation 🤤
        return (Activator.CreateInstance(
            type: StandardImage.GetProceduralType(typeof(OptimalDeviceImage2D<>), vkFormat),
            bindingAttr: BindingFlags.NonPublic | BindingFlags.Instance,
            binder: null,
            args: new object [] { image, device },
            culture: CultureInfo.CurrentCulture) as IImage)!;
    }
}